use std::{
    collections::HashMap,
    path::{Path, PathBuf},
};

use eyre::Context;
use serde::{Deserialize, Serialize};

const CURRENT_LOCKFILE_VERSION: u32 = 1;
const HEADER: &str = r#"# This file is automatically generated by selene.
# Do not edit this file manually.
# You probably want to commit this to your repository."#;

#[derive(Debug, Default)]
pub struct Lockfile {
    contents: LockfileContents,
    file: PathBuf,
    new_plugins: HashMap<String, PluginLock>,
}

impl Lockfile {
    pub fn open(root: &Path) -> eyre::Result<Self> {
        let lockfile_path = Self::lockfile_path(root);
        if !lockfile_path.exists() {
            return Ok(Lockfile {
                file: lockfile_path,
                ..Default::default()
            });
        }

        let lockfile: LockfileContents = toml::from_str(
            &std::fs::read_to_string(&lockfile_path).context("can't read lockfile")?,
        )
        .context("lockfile is not valid toml")?;

        if lockfile.version > CURRENT_LOCKFILE_VERSION {
            eyre::bail!("lockfile version `{}` is newer than the current version `{CURRENT_LOCKFILE_VERSION}`. please update selene.", lockfile.version);
        }

        Ok(Self {
            contents: lockfile,
            file: lockfile_path,
            new_plugins: HashMap::new(),
        })
    }

    pub fn lockfile_path(root: &Path) -> PathBuf {
        root.join("selene.lock")
    }

    pub fn get(&self, plugin: &str) -> Option<&PluginLock> {
        self.contents.plugin_hubs.get(plugin)
    }

    pub fn add(&mut self, plugin: String, lock: PluginLock) {
        self.new_plugins.insert(plugin, lock);
    }

    // PLUGIN TODO: Clear out old plugins
    pub fn save(mut self) -> eyre::Result<()> {
        if self.new_plugins.is_empty() {
            return Ok(());
        }

        self.contents.plugin_hubs.extend(self.new_plugins);
        std::fs::write(
            &self.file,
            format!("{HEADER}\n{}", toml::to_string(&self.contents)?),
        )?;
        Ok(())
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct LockfileContents {
    version: u32,
    plugin_hubs: HashMap<String, PluginLock>,
}

impl Default for LockfileContents {
    fn default() -> Self {
        Self {
            version: CURRENT_LOCKFILE_VERSION,
            plugin_hubs: HashMap::new(),
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct PluginLock {
    pub sha512: String, // SHA512 of the zip file, not the commit hash
    pub commit: String, // The commit hash
}
